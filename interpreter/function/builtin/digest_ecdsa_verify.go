// Code generated by __generator__/interpreter.go at once

package builtin

import (
	"crypto"
	"crypto/ecdsa"
	"crypto/x509"
	"encoding/base64"
	"encoding/pem"
	"fmt"
	"math/big"

	"github.com/ysugimoto/falco/interpreter/context"
	"github.com/ysugimoto/falco/interpreter/function/errors"
	"github.com/ysugimoto/falco/interpreter/value"
)

const Digest_ecdsa_verify_Name = "digest.ecdsa_verify"

var Digest_ecdsa_verify_ArgumentTypes = []value.Type{value.IdentType, value.StringType, value.StringType, value.StringType, value.IdentType, value.IdentType}

func Digest_ecdsa_verify_Validate(args []value.Value) error {
	if len(args) < 5 || len(args) > 6 {
		return errors.ArgumentNotInRange(Digest_ecdsa_verify_Name, 5, 6, args)
	}
	for i := range args {
		if args[i].Type() != Digest_ecdsa_verify_ArgumentTypes[i] {
			return errors.TypeMismatch(Digest_ecdsa_verify_Name, i+1, Digest_ecdsa_verify_ArgumentTypes[i], args[i].Type())
		}
	}
	return nil
}

// Fastly built-in function implementation of digest.ecdsa_verify
// Arguments may be:
// - ID, STRING, STRING, STRING, ID
// - ID, STRING, STRING, STRING, ID, ID
// Reference: https://www.fastly.com/documentation/reference/vcl/functions/cryptographic/digest-ecdsa-verify/
func Digest_ecdsa_verify(ctx *context.Context, args ...value.Value) (value.Value, error) {
	// Argument validations
	if err := Digest_ecdsa_verify_Validate(args); err != nil {
		return value.Null, err
	}

	// Argument 1: hash_method
	hashMethod := value.Unwrap[*value.Ident](args[0]).Value
	// Argument 2: public_key
	publicKey := value.Unwrap[*value.String](args[1]).Value
	// Argument 3: payload
	payload := value.Unwrap[*value.String](args[2]).Value
	// Argument 4: digest
	digest := value.Unwrap[*value.String](args[3]).Value
	// Argument 5: digest format
	digestFormat := value.Unwrap[*value.Ident](args[4]).Value
	// Argument 6 (optional): base64_method
	base64Method := "url_nopad"
	if len(args) == 6 {
		base64Method = value.Unwrap[*value.Ident](args[5]).Value
	}

	pubKey, err := Digest_ecdsa_verify_DecodePublicKey(publicKey)
	if err != nil {
		return value.Null, errors.New(Digest_ecdsa_verify_Name, "Failed to decode public key, %w", err)
	}

	decodedDigest, err := Digest_ecdsa_verify_DecodeArgument(digest, base64Method)
	if err != nil {
		return value.Null, errors.New(Digest_ecdsa_verify_Name, "Failed to decode digest, %w", err)
	}

	// digestFormat only accepts "der" or "jwt"
	switch digestFormat {
	case "der":
		return Digest_ecdsa_verify_Der(hashMethod, pubKey, payload, decodedDigest)
	case "jwt":
		return Digest_ecdsa_verify_Jwt(hashMethod, pubKey, payload, decodedDigest)
	default:
		return value.Null, errors.New(Digest_ecdsa_verify_Name, "Invalid digest format '%s' provided, only accepts der or jwt", digestFormat)
	}
}

func Digest_ecdsa_verify_DecodePublicKey(pubKey string) (*ecdsa.PublicKey, error) {
	block, _ := pem.Decode([]byte(pubKey))
	if block == nil || block.Type != "PUBLIC KEY" {
		return nil, fmt.Errorf("Failed to parse PEM block of public key")
	}
	pub, err := x509.ParsePKIXPublicKey(block.Bytes)
	if err != nil {
		return nil, err
	}
	key, ok := pub.(*ecdsa.PublicKey)
	if !ok {
		return nil, fmt.Errorf("Failed to assert to ecdsa public key")
	}
	return key, nil
}

func Digest_ecdsa_verify_DecodeArgument(v string, b64 string) ([]byte, error) {
	switch b64 {
	case "standard":
		return base64.StdEncoding.DecodeString(v)
	case "url":
		// Trick: url decoding may error. Then we try to decode as nopadding
		dec, err := base64.RawURLEncoding.DecodeString(v)
		if err != nil {
			return base64.URLEncoding.DecodeString(v)
		}
		return dec, nil
	case "url_nopad":
		// Trick: url decoding may error. Then we try to decode with padding
		dec, err := base64.RawURLEncoding.DecodeString(v)
		if err != nil {
			return base64.URLEncoding.DecodeString(v)
		}
		return dec, nil
	default:
		return nil, fmt.Errorf("Invalid base64_method %s, 6th argument of %s", b64, Digest_ecdsa_verify_Name)
	}
}

func Digest_ecdsa_verify_Der(method string, pubKey *ecdsa.PublicKey, payload string, digest []byte) (value.Value, error) {
	var hash crypto.Hash

	// ASN.1 DER-encoded supports sha1, sha256, sha384, and sha512
	switch method {
	case "sha1":
		hash = crypto.SHA1
	case "sha256":
		hash = crypto.SHA256
	case "sha384":
		hash = crypto.SHA384
	case "sha512":
		hash = crypto.SHA512
	default:
		return value.Null, fmt.Errorf("Invalid hash_method %s provided on first argument of %s", method, Digest_ecdsa_verify_Name)
	}

	h := hash.New()
	h.Write([]byte(payload))

	return &value.Boolean{
		Value: ecdsa.VerifyASN1(pubKey, h.Sum(nil), digest),
	}, nil

}

const Digest_ecdsa_verify_Jwt_KeySize = 32

func Digest_ecdsa_verify_Jwt(method string, pubKey *ecdsa.PublicKey, payload string, digest []byte) (value.Value, error) {
	// JWT encode only supports sha256 (ES256)
	// see https://www.fastly.com/documentation/reference/vcl/functions/cryptographic/digest-ecdsa-verify/
	if method != "sha256" {
		return value.Null, fmt.Errorf("Only sha256 supports in hash_method for jwt digest, %s provided", method)
	}

	// Digest key size constant of 64 bytes
	if len(digest) != 2*Digest_ecdsa_verify_Jwt_KeySize {
		// return false without error if digest key length is not 64
		return &value.Boolean{
			Value: false,
		}, nil
	}

	r := big.NewInt(0).SetBytes(digest[:Digest_ecdsa_verify_Jwt_KeySize])
	s := big.NewInt(0).SetBytes(digest[Digest_ecdsa_verify_Jwt_KeySize:])

	hash := crypto.SHA256.New()
	hash.Write([]byte(payload))

	return &value.Boolean{
		Value: ecdsa.Verify(pubKey, hash.Sum(nil), r, s),
	}, nil
}
